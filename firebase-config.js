// Firebase Configuration for Butchery Loyalty Program
// This file contains Firebase initialization and database structure planning

/*
FIREBASE DATABASE STRUCTURE PLANNING:

Collections in Firestore:

1. customers/{phoneNumber}
   - Document ID: customer's phone number (e.g., "+1234567890")
   - Fields:
     * points: number (current loyalty points balance)
     * createdAt: timestamp (when customer registered)
     * password: string (hashed password for login)
     * name: string (optional customer name)

2. purchases/{autoId}
   - Document ID: auto-generated by Firestore
   - Fields:
     * customerPhone: string (reference to customer)
     * amount: number (purchase amount in currency)
     * pointsEarned: number (calculated as floor(amount/100) * 5)
     * createdAt: timestamp (when purchase was made)
     * createdBy: string (admin UID who processed the purchase)

3. redemptions/{autoId}
   - Document ID: auto-generated by Firestore
   - Fields:
     * customerPhone: string (reference to customer)
     * rewardKg: number (0.5 or 0.75 kg redeemed)
     * pointsSpent: number (100 or 180 points spent)
     * createdAt: timestamp (when redemption occurred)
     * processedBy: string (admin UID who processed redemption)

4. admins/{uid}
   - Document ID: Firebase Auth UID of admin user
   - Fields: {} (empty document, existence indicates admin status)

POINTS CALCULATION LOGIC:
- Customer spends money â†’ floor(amount / 100) * 5 points
- Example: $50 purchase = floor(50/100) * 5 = 0 * 5 = 0 points
- Example: $150 purchase = floor(150/100) * 5 = 1 * 5 = 5 points
- Example: $250 purchase = floor(250/100) * 5 = 2 * 5 = 10 points

REDEMPTION RULES:
- 100 points = 0.5kg meat
- 180 points = 0.75kg meat

FIREBASE SECURITY RULES NEEDED:
- Customers can only read/write their own data
- Admins can read/write all customer data
- All writes must be authenticated
*/

// Firebase configuration object (replace with your actual config)
const firebaseConfig = {
  apiKey: "AIzaSyDufK77VjSXLwH2cbbq3lE90eMjtz2ins4",
  authDomain: "butchery-loyalty-points-system.firebaseapp.com",
  projectId: "butchery-loyalty-points-system",
  storageBucket: "butchery-loyalty-points-system.firebasestorage.app",
  messagingSenderId: "525229819449",
  appId: "1:525229819449:web:85075b0d1771446be02fe8",
  measurementId: "G-MNHS0CSYJ0"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);

// Initialize Firestore and Auth
const db = firebase.firestore();
const auth = firebase.auth();

// Database helper functions
const DatabaseHelpers = {
  
  // Customer Operations
  async createCustomer(phoneNumber, password, name = '') {
    try {
      // Create authentication account first
      const userCredential = await auth.createUserWithEmailAndPassword(
        `${phoneNumber}@butchery.local`, // Convert phone to email format
        password
      );
      
      // Create customer document in Firestore
      await db.collection('customers').doc(phoneNumber).set({
        points: 0,
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        name: name,
        uid: userCredential.user.uid
      });
      
      return { success: true, user: userCredential.user };
    } catch (error) {
      console.error('Error creating customer:', error);
      return { success: false, error: error.message };
    }
  },

  async getCustomer(phoneNumber) {
    try {
      const doc = await db.collection('customers').doc(phoneNumber).get();
      if (doc.exists) {
        return { success: true, data: doc.data() };
      } else {
        return { success: false, error: 'Customer not found' };
      }
    } catch (error) {
      console.error('Error getting customer:', error);
      return { success: false, error: error.message };
    }
  },

  // Purchase Operations
  async addPurchase(customerPhone, amount, adminUid) {
    try {
      // Calculate points: floor(amount / 100) * 5
      const pointsEarned = Math.floor(amount / 100) * 5;
      
      // Use Firestore transaction to ensure data consistency
      return await db.runTransaction(async (transaction) => {
        // Get current customer data
        const customerRef = db.collection('customers').doc(customerPhone);
        const customerDoc = await transaction.get(customerRef);
        
        if (!customerDoc.exists) {
          throw new Error('Customer not found');
        }
        
        const currentPoints = customerDoc.data().points || 0;
        
        // Add purchase record
        const purchaseRef = db.collection('purchases').doc();
        transaction.set(purchaseRef, {
          customerPhone: customerPhone,
          amount: amount,
          pointsEarned: pointsEarned,
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          createdBy: adminUid
        });
        
        // Update customer points
        transaction.update(customerRef, {
          points: currentPoints + pointsEarned
        });
        
        return {
          success: true,
          pointsEarned: pointsEarned,
          newBalance: currentPoints + pointsEarned
        };
      });
    } catch (error) {
      console.error('Error adding purchase:', error);
      return { success: false, error: error.message };
    }
  },

  // Redemption Operations
  async redeemPoints(customerPhone, rewardType, adminUid) {
    try {
      const rewardConfig = {
        'small': { kg: 0.5, points: 100 },
        'large': { kg: 0.75, points: 180 }
      };
      
      const reward = rewardConfig[rewardType];
      if (!reward) {
        return { success: false, error: 'Invalid reward type' };
      }
      
      // Use Firestore transaction for atomic redemption
      return await db.runTransaction(async (transaction) => {
        // Get current customer data
        const customerRef = db.collection('customers').doc(customerPhone);
        const customerDoc = await transaction.get(customerRef);
        
        if (!customerDoc.exists) {
          throw new Error('Customer not found');
        }
        
        const currentPoints = customerDoc.data().points || 0;
        
        // Check if customer has enough points
        if (currentPoints < reward.points) {
          throw new Error(`Insufficient points. Need ${reward.points}, have ${currentPoints}`);
        }
        
        // Add redemption record
        const redemptionRef = db.collection('redemptions').doc();
        transaction.set(redemptionRef, {
          customerPhone: customerPhone,
          rewardKg: reward.kg,
          pointsSpent: reward.points,
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          processedBy: adminUid
        });
        
        // Deduct points from customer
        transaction.update(customerRef, {
          points: currentPoints - reward.points
        });
        
        return {
          success: true,
          pointsSpent: reward.points,
          rewardKg: reward.kg,
          newBalance: currentPoints - reward.points
        };
      });
    } catch (error) {
      console.error('Error redeeming points:', error);
      return { success: false, error: error.message };
    }
  },

  // Admin Operations
  async isAdmin(uid) {
    try {
      const doc = await db.collection('admins').doc(uid).get();
      return doc.exists;
    } catch (error) {
      console.error('Error checking admin status:', error);
      return false;
    }
  },

  async searchCustomers(phoneQuery) {
    try {
      // Search customers by phone number (starts with query)
      const snapshot = await db.collection('customers')
        .where(firebase.firestore.FieldPath.documentId(), '>=', phoneQuery)
        .where(firebase.firestore.FieldPath.documentId(), '<', phoneQuery + '\uf8ff')
        .limit(10)
        .get();
      
      const customers = [];
      snapshot.forEach(doc => {
        customers.push({
          phone: doc.id,
          ...doc.data()
        });
      });
      
      return { success: true, customers: customers };
    } catch (error) {
      console.error('Error searching customers:', error);
      return { success: false, error: error.message };
    }
  }
};

// Export for use in other files
window.DatabaseHelpers = DatabaseHelpers;
window.db = db;
window.auth = auth;
